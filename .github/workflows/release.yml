name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: release-${{ github.ref_name }}
  cancel-in-progress: true

jobs:
  release:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # macOS Intel (x86_64)
          - os: macos-14
            target: x86_64-apple-darwin
            arch: x86_64
          # macOS Apple Silicon (arm64)
          - os: macos-14
            target: aarch64-apple-darwin
            arch: aarch64
          # Windows x64 (Intel/AMD)
          - os: windows-2022
            target: x86_64-pc-windows-msvc
            arch: x64
          # Windows on Arm (aarch64)
          - os: windows-2022
            target: aarch64-pc-windows-msvc
            arch: arm64

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: npm

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri

      - name: Add macOS targets
        run: rustup target add ${{ matrix.target }}

      - name: Install macOS build deps
        if: matrix.os == 'macos-14'
        shell: bash
        run: |
          set -euxo pipefail
          brew install pkg-config cmake

      - name: Install Windows build deps
        if: matrix.os == 'windows-2022'
        shell: bash
        run: |
          set -euxo pipefail
          # Install Strawberry Perl for OpenSSL build (required by openssl-sys)
          choco install -y strawberryperl
          # Add Strawberry Perl to PATH
          export PATH="/c/Strawberry/perl/bin:$PATH"
          # WebView2 Runtime is pre-installed on windows-2022 runner
          rustup target add ${{ matrix.target }}

      - name: Install frontend deps
        run: npm ci

      - name: Prepare Tauri signing key
        shell: bash
        env:
          RAW_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          RAW_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          node <<'NODE'
          const fs = require('fs');

          const raw = (process.env.RAW_KEY || '').trim();
          if (!raw) {
            console.warn('⚠️ 未配置 TAURI_SIGNING_PRIVATE_KEY，将生成未签名版本');
            process.exit(0);
          }

          const looksLikeBase64 = (s) => /^[A-Za-z0-9+/=]+$/.test(s);
          const startsWithUntrusted = (s) => s.split(/\r?\n/)[0].startsWith('untrusted comment:');

          let normalized = '';
          if (startsWithUntrusted(raw)) {
            normalized = raw.endsWith('\n') ? raw : raw + '\n';
          } else if (looksLikeBase64(raw)) {
            try {
              const decoded = Buffer.from(raw, 'base64').toString('utf8');
              if (startsWithUntrusted(decoded.trim())) {
                normalized = decoded.trimEnd() + '\n';
              } else {
                normalized = `untrusted comment: tauri signing key\n${raw.replace(/\s+/g, '')}\n`;
              }
            } catch {
              normalized = `untrusted comment: tauri signing key\n${raw.replace(/\s+/g, '')}\n`;
            }
          } else {
            try {
              const decoded = Buffer.from(raw, 'base64').toString('utf8');
              if (startsWithUntrusted(decoded.trim())) {
                normalized = decoded.trimEnd() + '\n';
              } else {
                throw new Error('not minisign');
              }
            } catch {
              console.error('❌ TAURI_SIGNING_PRIVATE_KEY 格式无法识别（不是两行原文/其 base64/单行 base64）');
              process.exit(1);
            }
          }

          const keyB64 = Buffer.from(normalized, 'utf8').toString('base64');
          const envFile = process.env.GITHUB_ENV;
          fs.appendFileSync(envFile, `TAURI_SIGNING_PRIVATE_KEY=${keyB64}\n`);

          const pwd = (process.env.RAW_PASSWORD || '').trim();
          if (pwd) fs.appendFileSync(envFile, `TAURI_SIGNING_PRIVATE_KEY_PASSWORD=${pwd}\n`);
          NODE

      - name: Import Apple certificate (codesign)
        shell: bash
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY_INPUT: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          set -euo pipefail

          if [ -z "${APPLE_CERTIFICATE:-}" ]; then
            echo "ℹ️ 未配置 APPLE_CERTIFICATE，跳过 codesign 导入"
            exit 0
          fi
          if [ -z "${APPLE_CERTIFICATE_PASSWORD:-}" ]; then
            echo "❌ 缺少 Secret：APPLE_CERTIFICATE_PASSWORD" >&2
            exit 1
          fi
          if [ -z "${KEYCHAIN_PASSWORD:-}" ]; then
            echo "❌ 缺少 Secret：KEYCHAIN_PASSWORD" >&2
            exit 1
          fi

          CERT_PATH="$RUNNER_TEMP/certificate.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/build.keychain-db"

          echo "$APPLE_CERTIFICATE" | (base64 --decode 2>/dev/null || base64 -D) > "$CERT_PATH"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH"
          security default-keychain -s "$KEYCHAIN_PATH"

          security import "$CERT_PATH" -k "$KEYCHAIN_PATH" -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          echo "Available identities:"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true

          if [ -n "${APPLE_SIGNING_IDENTITY_INPUT:-}" ]; then
            echo "APPLE_SIGNING_IDENTITY=${APPLE_SIGNING_IDENTITY_INPUT}" >> "$GITHUB_ENV"
          else
            IDENTITY="$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | head -n 1 | sed -n 's/.*\"\\(.*\\)\".*/\\1/p' || true)"
            if [ -z "$IDENTITY" ]; then
              echo "❌ 未能从 keychain 推断 APPLE_SIGNING_IDENTITY，请配置 Secret：APPLE_SIGNING_IDENTITY" >&2
              exit 1
            fi
            echo "APPLE_SIGNING_IDENTITY=$IDENTITY" >> "$GITHUB_ENV"
          fi

      - name: Build Tauri App (macOS)
        if: matrix.os == 'macos-14'
        # updater 产物（*.tar.gz/*.sig）是基于 .app bundle 生成的，因此必须包含 app
        shell: bash
        run: |
          set -euo pipefail
          echo "=== Building Tauri App for macOS ==="
          echo "Target: ${{ matrix.target }}"
          echo "Arch: ${{ matrix.arch }}"
          if [ -n "${APPLE_SIGNING_IDENTITY:-}" ]; then
            echo "✅ 使用 APPLE_SIGNING_IDENTITY=$APPLE_SIGNING_IDENTITY 进行签名"
          else
            echo "ℹ️ 未配置 APPLE_SIGNING_IDENTITY，构建未签名版本"
            unset APPLE_SIGNING_IDENTITY
          fi
          npm run tauri:build -- --target ${{ matrix.target }} --bundles app,dmg
          echo "=== Build completed ==="
          ls -la src-tauri/target/${{ matrix.target }}/release/bundle/ || true

      - name: Build Tauri App (Windows)
        if: matrix.os == 'windows-2022'
        # Windows 产物：只生成 NSIS 安装程序
        shell: bash
        run: |
          set -euo pipefail
          echo "=== Building Tauri App for Windows ==="
          echo "Target: ${{ matrix.target }}"
          echo "Arch: ${{ matrix.arch }}"
          # Add Strawberry Perl to PATH for OpenSSL build
          export PATH="/c/Strawberry/perl/bin:$PATH"
          npm run tauri:build -- --target ${{ matrix.target }} --bundles nsis --no-sign
          echo "=== Build completed ==="
          ls -la src-tauri/target/${{ matrix.target }}/release/bundle/ || true

      - name: Verify codesign (optional)
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${APPLE_CERTIFICATE:-}" ]; then
            echo "ℹ️ 未配置 APPLE_CERTIFICATE，跳过验签"
            exit 0
          fi
          TARGET="${{ matrix.target }}"
          APP_PATH="$(find "src-tauri/target/${TARGET}/release/bundle" -type d -name "*.app" | head -n 1 || true)"
          if [ -z "$APP_PATH" ]; then
            echo "⚠️ 未找到 .app，跳过验签" >&2
            exit 0
          fi
          echo "APP_PATH=$APP_PATH"
          codesign -dv --verbose=4 "$APP_PATH" || true
          codesign --verify --deep --strict --verbose=4 "$APP_PATH"

      - name: Prepare macOS Assets
        if: matrix.os == 'macos-14'
        shell: bash
        run: |
          set -euo pipefail

          mkdir -p release-assets
          VERSION="${GITHUB_REF_NAME}" # e.g. v0.1.4
          ARCH="${{ matrix.arch }}"
          TARGET="${{ matrix.target }}"

          # 产物路径在不同 target 下可能不同：优先 target/<triple>/...，兜底 target/release/...
          BUNDLE_DIRS=(
            "src-tauri/target/${TARGET}/release/bundle"
            "src-tauri/target/release/bundle"
          )

          TAR_GZ=""
          DMG=""
          for dir in "${BUNDLE_DIRS[@]}"; do
            if [ -d "${dir}" ]; then
              if [ -z "${TAR_GZ}" ]; then
                TAR_GZ="$(find "${dir}" -type f -name "*.tar.gz" | head -n 1 || true)"
              fi
              if [ -z "${DMG}" ]; then
                DMG="$(find "${dir}" -type f -name "*.dmg" | head -n 1 || true)"
              fi
            fi
          done

          if [ -z "${TAR_GZ}" ]; then
            echo "❌ 未找到 *.tar.gz updater 产物（target=${TARGET}, arch=${ARCH}）。请确认 `src-tauri/tauri.conf.json` 已设置 `bundle.createUpdaterArtifacts=true`，且构建包含 `--bundles app`。" >&2
            for dir in "${BUNDLE_DIRS[@]}"; do
              echo "---- list: ${dir}" >&2
              ls -la "${dir}" 2>/dev/null || true
              find "${dir}" -maxdepth 6 -type f 2>/dev/null | head -n 200 >&2 || true
            done
            exit 1
          fi

          if [ ! -f "${TAR_GZ}.sig" ]; then
            echo "❌ 未找到 updater 签名文件：${TAR_GZ}.sig" >&2
            exit 1
          fi

          NEW_TAR_GZ="Skills-Hub-${VERSION}-macOS-${ARCH}.tar.gz"
          cp "${TAR_GZ}" "release-assets/${NEW_TAR_GZ}"
          cp "${TAR_GZ}.sig" "release-assets/${NEW_TAR_GZ}.sig"

          if [ -n "${DMG}" ]; then
            NEW_DMG="Skills-Hub-${VERSION}-macOS-${ARCH}.dmg"
            cp "${DMG}" "release-assets/${NEW_DMG}"
          else
            echo "⚠️ 未找到 macOS .dmg（可选）" >&2
          fi

      - name: Prepare Windows Assets
        if: matrix.os == 'windows-2022'
        shell: bash
        run: |
          set -euo pipefail

          mkdir -p release-assets
          VERSION="${GITHUB_REF_NAME}" # e.g. v0.1.4
          ARCH="${{ matrix.arch }}"
          TARGET="${{ matrix.target }}"

          # 产物路径在不同 target 下可能不同：优先 target/<triple>/...，兜底 target/release/...
          BUNDLE_DIRS=(
            "src-tauri/target/${TARGET}/release/bundle"
            "src-tauri/target/release/bundle"
          )

          EXE=""
          for dir in "${BUNDLE_DIRS[@]}"; do
            if [ -d "${dir}" ]; then
              if [ -z "${EXE}" ]; then
                EXE="$(find "${dir}" -type f -name "*.exe" | head -n 1 || true)"
              fi
            fi
          done

          if [ -z "${EXE}" ]; then
            echo "❌ 未找到 *.exe 安装程序（target=${TARGET}, arch=${ARCH}）。请确认构建包含 `--bundles nsis`。" >&2
            for dir in "${BUNDLE_DIRS[@]}"; do
              echo "---- list: ${dir}" >&2
              ls -la "${dir}" 2>/dev/null || true
              find "${dir}" -maxdepth 6 -type f 2>/dev/null | head -n 200 >&2 || true
            done
            exit 1
          fi

          NEW_EXE="Skills-Hub-${VERSION}-Windows-${ARCH}.exe"
          cp "${EXE}" "release-assets/${NEW_EXE}"

      - name: List prepared assets
        shell: bash
        run: ls -la release-assets || true

      - name: Upload workflow artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-assets-${{ matrix.arch }}
          path: release-assets/*
          if-no-files-found: error

  assemble-updater-json:
    name: Assemble updater.json
    runs-on: macos-14
    needs: release
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download workflow artifacts
        uses: actions/download-artifact@v4
        with:
          path: dl
          pattern: release-assets-*
          merge-multiple: true

      - name: Generate updater.json
        env:
          REPO: ${{ github.repository }}
          TAG: ${{ github.ref_name }}
        shell: bash
        run: |
          set -euo pipefail

          VERSION="${TAG#v}"
          PUB_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          base_url="https://github.com/$REPO/releases/download/$TAG"

          mac_arm_url=""; mac_arm_sig=""
          mac_x64_url=""; mac_x64_sig=""

          ls -la dl || true

          shopt -s nullglob
          for sig in dl/*.sig; do
            base=${sig%.sig}
            fname=$(basename "$base")
            url="$base_url/$fname"
            sig_content=$(tr -d '\r\n' < "$sig")
            case "$fname" in
              *-macOS-aarch64.tar.gz)
                mac_arm_url="$url"; mac_arm_sig="$sig_content";;
              *-macOS-x86_64.tar.gz)
                mac_x64_url="$url"; mac_x64_sig="$sig_content";;
            esac
          done

          if [ -z "${mac_arm_url:-}" ] && [ -z "${mac_x64_url:-}" ]; then
            echo "❌ 未找到任何 macOS updater 签名（dl/*.sig）; 请确认构建产物包含 *.tar.gz.sig" >&2
            exit 1
          fi

          tmp_json=$(mktemp)
          {
            echo '{'
            echo "  \"version\": \"$VERSION\","
            echo "  \"notes\": \"Release $TAG\","
            echo "  \"pub_date\": \"$PUB_DATE\","
            echo '  "platforms": {'
            first=1
            if [ -n "${mac_arm_url:-}" ] && [ -n "${mac_arm_sig:-}" ]; then
              [ $first -eq 0 ] && echo ','
              echo "    \"darwin-aarch64\": {\"signature\": \"$mac_arm_sig\", \"url\": \"$mac_arm_url\"}"
              first=0
            fi
            if [ -n "${mac_x64_url:-}" ] && [ -n "${mac_x64_sig:-}" ]; then
              [ $first -eq 0 ] && echo ','
              echo "    \"darwin-x86_64\": {\"signature\": \"$mac_x64_sig\", \"url\": \"$mac_x64_url\"}"
              first=0
            fi
            echo '  }'
            echo '}'
          } > "$tmp_json"

          cat "$tmp_json"
          mv "$tmp_json" updater.json

      - name: Generate release notes from changelog
        env:
          TAG: ${{ github.ref_name }}
        shell: bash
        run: |
          set -euo pipefail
          node scripts/extract-changelog.mjs "$TAG" CHANGELOG.md > release-notes.md
          {
            echo
            echo '**Windows Note:** Windows SmartScreen may show a warning during installation. This is normal for unsigned executables. The application is safe to use.'
            echo
            echo '**macOS Note:** macOS Gatekeeper workaround (only needed on some macOS versions): `xattr -cr "/Applications/Skills Hub.app"` (https://v2.tauri.app/distribute/#macos).'
          } >> release-notes.md

      - name: Create/Update GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: Skills Hub ${{ github.ref_name }}
          prerelease: ${{ contains(github.ref_name, '-') }}
          body_path: release-notes.md
          files: |
            dl/*
            updater.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
